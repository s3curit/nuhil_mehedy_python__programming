## while লুপ  

আগের কিছু চ্যাপ্টারে আমরা দেখেছি কিভাবে একটি if স্টেটমেন্টের কন্ডিশন সত্য হলে তার আওতাভুক্ত একটি কোড ব্লক রান করানো যায়। if এর ক্ষেত্রে কন্ডিশন সত্য হলে কোড ব্লকটি মাত্র একবার রান হয়। while লুপ মোটামুটি একইরকম ভাবে কাজ করে। যেমন - এরও একটি কন্ডিশন দরকার হয় এবং সেটি সত্য হলে, এর আওতাভুক্ত কোড রান করে। কিন্তু গুরুত্বপূর্ণ বিষয়টি হচ্ছে শুধু একবার না বরং অনেক বার রান করানো যায় (একে iteration বলে)।  

অর্থাৎ, যতক্ষণ সেই while লুপের কন্ডিশন সত্য থাকে ততক্ষণ পর্যন্ত এর আওতাভুক্ত কোড রান করতেই থাকে। আর যখন কন্ডিশনটি মিথ্যা হয়ে যায় তখন while লুপের বাইরে গিয়ে প্রোগ্রামের পরবর্তী স্টেটমেন্ট গুলো রান করা শুরু করে।  

উদাহরণ,

```python
i = 1
while i <= 5:
   print(i)
   i = i + 1

print("I am priting eventually cause the WHILE loop is done with his job.")
```

উপরের প্রোগ্রামে প্রথমেই একটি ভ্যারিয়েবল `i` নেওয়া হয়েছে এবং এর মান সেট করা হয়েছে `1`. এরপর একটি while লুপ এর শুরু হয়েছে। আগেই বলেছি এটিও  `if` এর মত কন্ডিশন সত্য কিনা তা যাচাই করে। তাহলে কি দাঁড়াচ্ছে? `while i <= 5:` এখানে এসে আমরা দেখছি কন্ডিশনটি সত্য। তার মানে এর আওতাভুক্ত কোড কাজ করবে। তাহলে দেখে নেই এর আওতাভুক্ত কোড কি আছে। প্রথমেই আছে একটা `print` এর কাজ যেটা প্রিন্ট করবে `i` এর বর্তমান মান তথা `1`. এর পর আরও একটা স্টেটমেন্ট আছে যেটাও কিনা সেই `while` এরই আওতাভুক্ত। তার মানে সেটিও এক্সিকিউট হবে। সেই স্টেটমেন্টটির কাজ হচ্ছে `i` এর মান এক বাড়িয়ে দেয়া। এভাবে `while` লুপের একবার কাজ করা শেষ। কিন্তু এটি `if` এর মত একবার কাজ করেই শেষ হয়ে যায় না। বরং আবার কন্ডিশন চেক করতে ফিরে যায় এর কার্যক্রমের প্রথমে অর্থাৎ `while i <= 5:` এই লাইনে।  

এখানে এসে চেক করার সময় `i` এর মান পায় `2` যেটা এখন পর্যন্ত সত্য অর্থাৎ `2` কিন্তু `5` এর ছোট। তাই আবারো লুপের মধ্যে থাকা কাজ করতে ঢুকে যায়। আবারো `i` এর মান প্রিন্ট করে এবং এর মান এক বাড়িয়ে লুপের শুরুতে ফিরে যায়। এভাবে একবার `i` এর মান `6` হয় এবং লুপের শুরুতে ফিরে গিয়ে প্রোগ্রাম যখন চেক করে `i` তথা `6` কিন্তু `5` এর ছোট বা সমান নয়। তখন আর লুপের মধ্যেকার কোড গুলো রান না করে লুপ থেকে একবারে বেরিয়ে পরবর্তী অন্যান্য স্টেটমেন্ট গুলো রান করা শুরু করে।    

লুপের বাইরে আমাদের একটি স্টেটমেন্ট আছে `print("I am printing eventually cause the WHILE loop is done with his job.")` যেটা একবার রান হয় কিন্তু তার আগে `while` লুপ তার কন্ডিশন মোতাবেক একাধিক বার রান হয়ে তার দায়িত্ব শেষ করেছিল।   

আউটপুট, 

```python
1
2
3
4
5
I am priting eventually cause the WHILE loop is done with his job.
```   

**infinite লুপ**   
একটা কথা মাথায় আসতে পারে আমাদের সেটা হচ্ছে - যদি `while` লুপ একটা কন্ডিশন যতক্ষণ সত্য হয় ততক্ষণ রান করে তাহলে একটা কাজ করলে কেমন হয়; এমন একটা কন্ডিশন সেট করে দেবো ওর জন্য যেটা কোনদিন মিথ্যাই হবে না :P তাহলে `while` লুপ এর কাজ তো শেষই হবার কথা না, তাই না? 

হ্যাঁ, ঠিক এরকম আজীবন চলা লুপকে inifinite লুপ বলা যেতে পারে। 

উদাহরণ, 

```python
while 1 == 1:
   print("In the loop")
```

এখানে `while` লুপের জন্য কন্ডিশন সেট করেছি এরকম যে - যতক্ষণ ১ এর সমান ১ হবে ততক্ষণ সে তার মধ্যেকার কোড রান করবে। আর আমরা সবাই জানি যে, সারাজীবনই ১ আর ১ সমান। আর তাই এই লুপ লজিক্যালি একটি infinite লুপ। 

> উপরের প্রোগ্রাম লিখে কেউ রান করার চেষ্টা করলে স্ট্যান্ডার্ড আউটপুট স্ক্রিনে অনবরত `In the loop` লেখাটি আসতেই থাকবে। এমতাবস্থায়, কিবোর্ডের `ctrl+C` চেপে প্রোগ্রামটির কার্যক্রম বন্ধ করা যাবে।   

**break**  
কিন্তু এরকম জোড় করে বন্ধ করা পছন্দ না হলে জানিয়ে রাখা ভালো যে - প্রোগ্রাম্যাটিক্যালিও `while` লুপের কাজ যেকোনো সময় কন্ডিশনের পরোয়া না করেও বন্ধ করা সম্ভব। এর জন্য শুধু লিখতে হবে `break`. 

উদাহরণ, 

```python
i = 0
while 1 == 1:
   print(i)
   i = i + 1
   if i >= 5:
      print("Breaking")
      break

print("Finished")
```  

উপরের প্রোগ্রামটি দেখে আপাতদৃষ্টিতে মনে হতে পারে এটি একটি infinite লুপ। ধারনা ঠিকি আছে কিন্তু আমরা একে অনন্তকাল চলতে না দিয়ে একটা ছোট্ট লজিকের উপর ভিত্তি করে এর চলমান প্রক্রিয়া বন্ধ করে দিয়েছি। অর্থাৎ অনন্তকাল চলার ইচ্ছায় কাজ শুরু করে ৫ বার চলার পর আমাদের `while` এর কন্ট্রোলার এর মধ্যে থাকা `if` এর ফাঁদে (সত্যতায়) পরে যায়। আর আমরা বুদ্ধি করে সেই `if` এর কোড ব্লকের মধ্যে লিখেছি একটি প্রিন্ট স্টেটমেন্ট এবং সেই মহা ঘাতক `break`. আর তাই, এ অবস্থায় এসে ১ এর সমান ১ এবং বাকী সব ভুলে `while` লুপ তার কার্যক্রমে ক্ষান্ত দেয় এবং প্রোগ্রামের কন্ট্রোল চলে যায় নিচের সাধারণ প্রিন্ট স্টেটমেন্টে `print("Finished")`

আউটপুট,

```python
0
1
2
3
4
Breaking
Finished
```

**continue**  
এটি আরেকটি মজার জিনিষ। ধরা যাক, একটি লুপের মধ্যে আমরা বেশ কিছু কাজ করার স্টেটমেন্ট লিখেছি এবং চাচ্ছি যে লুপ যতক্ষণ সত্য থাকে (ধরে নেই ১০০ বার) ততক্ষণ এর মধ্যেকার কাজ গুলো বার বার হোক। কিন্তু, এমনও তো হতে পারে যে, সেই ১০০ বারের মধ্যে বিশেষ কয়েকবার আমরা সেই পুরো কাজটা করতে চাই না কিন্তু নির্ধারিত ১০০ বারই লুপকে কাজ করাতে দিতে চাই; তাহলে কি করতে পারি?   
এর জন্যই আছে `continue`. একটি `while` লুপের মধ্যে যখনই `continue` এক্সিকিউট হবে তখনিই লুপের মধ্যে থাকা এর পরের কোড গুলো এক্সিকিউট হবে না এবং লুপের কন্ট্রোল একদম শুরুতে চলে যাবে।   
নিচের উদাহরণ দেখলে বিষয়টি পরিষ্কার হয়ে যাবে, 

```python
i = 0
while True:
   i = i +1
   if i == 2:
      print("Skipping 2")
      continue
   if i == 5:
      print("Breaking")
      break
   print(i)

print("Finished")
```  

আউটপুট, 

```python
1
Skipping 2
3
4
Breaking
Finished
```   

উপরের লুপটি একটি ইনফিনিট লুপ হলেও একটু বিশেষ ভাবে নিয়ন্ত্রণ করেছি। যেমন যেবার `i` এর মান `2` হয়েছে সেই বার `continue` এক্সিকিউশনের মাধ্যমে লুপকে জোড় করে শুরুতে নিয়ে যাওয়া হয়েছে তাই ওই বারের `2` প্রিন্ট হয় নি। এরপর আবার সাধারণভাবে `3,4` প্রিন্ট হয়েছে। আবার যখন `5` পেয়েছি তখনি `if` এর সত্যতার কারনে `break` এর এক্সিকিউশন হয়েছে এবং লুপ অকালে (এর অনন্তকাল চলার প্ল্যান ছিল) শেষ হয়েছে।   

>  সংকলন - [নুহিল মেহেদী](https://nuhil.net)

