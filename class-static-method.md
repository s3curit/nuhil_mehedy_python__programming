## ক্লাস মেথড ও স্ট্যাটিক মেথড   

**ক্লাস মেথড**   
আমরা আগেই জেনেছি, ইন্সট্যান্স মেথডকে একটি ক্লাসের ইন্সট্যান্স এর মাধ্যমে কল করা হয় এবং সেই ইন্সট্যান্সকে ওই মেথডের `self` প্যারামিটার হিসেবে পাঠানো হয় (ক্লাসের মেথড গুলোর প্রথম প্যারামিটার হিসেবে `self` ডিফাইন করতে হয়)।    

কিন্তু ক্লাস মেথড একটু আলাদা। এ ধরনের মেথডকে সরাসরি ক্লাসের মাধ্যমেই কল করা হয় এবং সেই ক্লাস কে ওই মেথডের `cls` প্যারামিটার হিসেবে পাঠানো হয় (ক্লাস মেথডের প্রথম প্যারামিটার সাধারণত `cls` হয়ে থাকে)।    

`classmethod` ডেকোরেটর ব্যবহার করে ক্লাস মেথড নির্দেশিত করা হয়। যেমন,    

```python
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def calculate_area(self):
        return self.width * self.height

    @classmethod
    def new_square(cls, side_length):
        return cls(side_length, side_length)

square = Rectangle.new_square(5)
print(square.calculate_area())
```

উপরের উদাহরণে, `new_square` একটি ক্লাস মেথড। আর তাই একে আমরা ক্লাসের মাধ্যমেই কল করতে পারি। একটি বিষয় লক্ষণীয় যে, এ ধরনের মেথডের প্রথম প্যারামিটার হিসেবে `cls` তথা সেই ক্লাসকেই পাঠানো হয়।    

> ইন্সট্যান্স মেথডের `self` এবং ক্লাস মেথডের `cls` এর নামকরণ শুধুই একটু কনভেনশন। আলাদা নামও চাইলে ব্যবহার করা যেতে পারে।    

আর সেই `new_square` মেথডের প্যারামিটার হচ্ছে একটি। তার মানে আমরা এই মেথডকে কল করতে পারছি একটি মাত্র প্যারামিটার দিয়েই এবং যেহেতু তার প্রথম প্যারামিটার হিসেবে সেই ক্লাসটি নিজেই নির্দেশিত হচ্ছে তার মানে ওই `new_square` মেথডের মধ্যে থেকে আমরা সেই ক্লাস তথা `Rectangle` কেই ধরে সেটাকে ইন্সট্যান্সিয়েট করতে পারি। `return cls(side_length, side_length)`  লাইনে আমরা ঠিক সেই কাজটিই করছি অর্থাৎ, `Rectangle` ক্লাসের কন্সট্রাক্টর এর দুটি প্যারামিটারের চাহিদা মোতাবেক দুটি প্যারামিটারই পাঠিয়ে ফ্রেশ একটি `Rectangle` ক্লাসের অবজেক্ট ইনিশিয়েট করেছি এবং রিটার্ন করছি।    

তার মানে, `square = Rectangle.new_square(5)` লাইনের মাধ্যমে আমরা `square` ভ্যারিয়েবলের মধ্যে বস্তুত স্ট্যান্ডার্ড `Rectangle` ক্লাসের অবজেক্ট পাচ্ছি। আর তাই শেষ লাইনে সেই অবজেক্টের মেথড তথা একটি স্বাভাবিক ইন্সট্যান্স মেথড `calculate_area` কে কল করে আশানরুপ ফল পাই।   

উপরের প্রোগ্রামের আউটপুট, 

```python
25
```

> ক্লাস মেথডের বহুল ব্যবহার হতে পারে ফ্যাক্টরি মেথড তৈরি জন্য যেখানে একটি ক্লাসের অবজেক্ট দরকার হলে আমরা চাইলে ওই ক্লাসের কন্সট্রাক্টরের চাহিদা মোতাবেক আর্গুমেন্ট না পাঠিয়েও আরেকটি মেথডের মাধ্যমে (এ ক্ষেত্রে ক্লাস মেথড) ওই ক্লাসের স্বাভাবিক একটি অবজেক্ট পেতে পারি।   

<br/>
**স্ট্যাটিক মেথড**   
স্ট্যাটিক মেথড অনেকটাই ক্লাস মেথডের মত যেমন, সরাসরি ক্লাস এর মাধ্যমেই কল করা যায়। কিন্তু আবার একটু আলাদা যেমন, ক্লাস মেথডের মত এই মেথড এর প্রথম প্যারামিটার হিসেবে কলার ক্লাসকে পাঠাতে হয় না।    
আর তাই, সহজ ভাবে স্ট্যাটিক মেথডকে নরমাল ফাংশনের সাথে তুলনা করা হয় কিন্তু যা বিশেষত ক্লাসের এলিমেন্ট অর্থাৎ ক্লাস বা ক্লাসের ইন্সট্যান্স এর মাধ্যমে কল করা যায়। `staticmethod` ডেকোরেটর ব্যবহার করে স্ট্যাটিক মেথড ডিফাইন করা হয়।    

উদাহরণ, 

```python
class Pizza:
    def __init__(self, toppings):
        self.toppings = toppings

    @staticmethod
    def validate_topping(topping):
        if topping == "pineapple":
            raise ValueError("No pineapples!")
        else:
            return True

ingredients = ["cheese", "onions", "spam"]
if all(Pizza.validate_topping(i) for i in ingredients):
    pizza = Pizza(ingredients)
```

উপরের প্রোগ্রামটি কোন এক্সেপশন ছাড়াই রান করবে। এখানে `validate_topping` একটি স্ট্যাটিক মেথড। ফর লুপ ব্যবহার করে `Pizza.validate_topping(i)` স্টেটমেন্টের মাধ্যমে `ingredients` লিস্টের প্রত্যেকটি এলিমেন্টের জন্য আমরা স্ট্যাটিক মেথডটিকে কল করে একটা সাধারণ চেকিং এর কাজ সম্পন্ন করেছি এবং তা সফল হলে `Pizza` ক্লাসের অবজেক্ট তৈরি করেছি।    

>  সংকলন - [নুহিল মেহেদী](https://nuhil.net)

 

